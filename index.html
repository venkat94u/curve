<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mobile Orderflow — Balanced Institutional Dashboard (Deep Walls)</title>

<!-- Combined Final File: HTML + CSS + JS (WS + REST deep snapshots + Historical replay) -->

<style>
:root{
  --bg:#071226;
  --card:#0f2030;
  --muted:#9fb0c8;
  --accent:#00d084;
  --buy:#66ffb2;
  --sell:#ff7b7b;
  --text:#e6f0fb;
  --border:#152433;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;font-family:Inter,system-ui,Roboto,Arial;background:var(--bg);color:var(--text);-webkit-font-smoothing:antialiased}
.wrap{max-width:1180px;margin:12px auto;padding:14px}
.header{display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap}
.title{font-size:20px;margin:0 0 2px 0;font-weight:600}
.subtitle{font-size:13px;color:var(--muted)}
.controls{display:flex;gap:8px;align-items:center}
select,input,button{padding:8px 10px;border-radius:8px;border:1px solid var(--border);background:#071b2b;color:var(--text);font-size:13px}
select{min-width:180px}
button{cursor:pointer}
.card{background:var(--card);padding:12px;border-radius:12px;box-shadow:0 6px 18px rgba(0,0,0,0.45);margin-top:12px;border:1px solid var(--border)}
.row{display:flex;justify-content:space-between;align-items:center}
.muted{color:var(--muted);font-size:13px}
.grid{display:grid;grid-template-columns:1fr 380px;gap:14px;margin-top:12px}
@media (max-width:920px){ .grid{grid-template-columns:1fr} .header{flex-direction:column;align-items:flex-start} }
.trade-list{height:260px;overflow:auto;padding:6px;margin-top:8px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent)}
.trade{display:flex;justify-content:space-between;padding:6px;border-radius:6px;margin-bottom:4px;font-size:13px}
.buy{color:var(--buy)} .sell{color:var(--sell)}
.small{font-size:12px;color:var(--muted)}
.table{font-size:13px;line-height:1.45}
.badge{display:inline-block;padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.02);font-size:13px}
.alertBox{padding:12px;border-radius:10px;margin-bottom:10px}
.swing-high{background:rgba(255,90,90,0.10);border:1px solid rgba(255,90,90,0.25);color:#ffb3b3}
.swing-low{background:rgba(0,210,130,0.10);border:1px solid rgba(0,210,130,0.28);color:#baffdf}
#swingPanelContainer{max-height:260px;overflow-y:auto;margin-bottom:6px}
.radar{
  display:flex;
  gap:10px;
  flex-direction:column;
  margin-top:10px;
}
.radar .row{align-items:flex-start}
.radar .col{flex:1;min-height:160px;max-height:360px;overflow:auto;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02);border:1px solid var(--border)}
.radar h4{margin:0 0 6px 0;font-size:14px}
.l2-grid{display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:8px}
.l2-grid .table{max-height:280px;overflow:auto;padding:8px;border-radius:8px;background:rgba(255,255,255,0.01)}
.center{display:flex;align-items:center;justify-content:center}
.hidden{display:none}
.stars{font-family: "Segoe UI Symbol", "Noto Color Emoji", "Apple Color Emoji", sans-serif;letter-spacing:2px}
</style>
</head>
<body>
<div class="wrap">
  <div class="header">
    <div>
      <h1 class="title">Orderflow Analyst — Balanced (Mobile)</h1>
      <div class="subtitle">Option C — Microstructure swing (sweep + delta flip) + Deep Wall Radar</div>
    </div>
    <div class="controls">
      <label class="small muted">Symbol</label>
      <select id="symbol"></select>
      <label class="small muted">Mode</label>
      <select id="modeSelect">
        <option value="ws">WS only (fast)</option>
        <option value="rest">REST deep (snapshot)</option>
        <option value="both" selected>Both (recommended)</option>
      </select>
      <button id="connectBtn">Connect</button>
      <button id="disconnectBtn" style="display:none">Disconnect</button>
      <span id="status" class="small muted">Disconnected</span>
    </div>
  </div>

  <div class="card">
    <div class="row">
      <div style="flex:1">
        <div id="swingPanelContainer"></div>

        <div style="display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin-top:8px">
          <div>
            <div class="small muted">Calibration</div>
            <div id="calib" class="small">Not running</div>
          </div>
          <div>
            <div class="small muted">Cumulative Delta</div>
            <div id="cumlDelta">0</div>
          </div>
          <div>
            <div class="small muted">Buy / Sell Vol</div>
            <div id="vols">0 / 0</div>
          </div>
          <div>
            <div class="small muted">Strength</div>
            <div id="strength">—</div>
          </div>
        </div>
      </div>
      <div style="width:260px;text-align:right">
        <div class="small muted">Tune</div>
        <div style="display:flex;gap:8px;align-items:center;justify-content:flex-end;margin-top:8px">
          <label class="small muted">WallSize</label>
          <input id="wallSize" value="50" style="width:70px"/>
          <label class="small muted">Burst</label>
          <input id="burstCnt" value="8" style="width:70px"/>
        </div>
      </div>
    </div>
  </div>

  <div class="grid">
    <div>
      <div class="card">
        <div class="small muted">Sweep & Divergence</div>
        <div id="sweepInfo" style="margin-top:8px">Sweep: — | Divergence: —</div>
      </div>

      <div class="card">
        <div class="small muted">Divergence Detail</div>
        <div id="divergenceInfo" style="margin-top:8px">—</div>
      </div>

      <div class="card">
        <div class="small muted">Market Order Bursts</div>
        <div style="display:flex;gap:14px;margin-top:10px">
          <div><div class="small muted">Buy Burst</div><div id="buyBurst" class="big">0</div></div>
          <div><div class="small muted">Sell Burst</div><div id="sellBurst" class="big">0</div></div>
          <div><div class="small muted">Aggressive</div><div id="aggr" class="big">—</div></div>
        </div>
      </div>

      <div class="card">
        <div class="row">
          <div class="small muted">Recent Trades (live)</div>
          <div class="small muted">max 200</div>
        </div>
        <div id="trades" class="trade-list"></div>
      </div>

      <div class="card">
        <div class="small muted">Logs</div>
        <div id="logs" style="max-height:120px;overflow:auto;margin-top:8px" class="small"></div>
      </div>
    </div>

    <div>
      <div class="card">
        <div class="small muted">Top-of-book</div>
        <div style="display:flex;justify-content:space-between;margin-top:8px">
          <div><div class="small muted">Best Bid</div><div id="bestBid" class="big">-</div></div>
          <div><div class="small muted">Best Ask</div><div id="bestAsk" class="big">-</div></div>
        </div>
      </div>

      <div class="card">
        <div class="small muted">Wall Clusters</div>
        <div style="margin-top:8px">
          <div class="small muted">Buy clusters: <span id="buyCluster">0</span></div>
          <div class="small muted">Sell clusters: <span id="sellCluster">0</span></div>

          <div style="margin-top:10px">
            <div class="small muted">Top buy walls</div>
            <div id="topBids" class="table"></div>
          </div>

          <div style="margin-top:10px">
            <div class="small muted">Top sell walls</div>
            <div id="topAsks" class="table"></div>
          </div>
        </div>
      </div>

      <div class="card">
        <div class="small muted">Controls</div>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="clearBtn">Clear State</button>
          <button id="downloadBtn">Download L2 CSV</button>
        </div>
        <div class="small muted footer-note" style="margin-top:8px">Auto reconnect enabled. Using WS + REST deep snapshots.</div>
      </div>
    </div>
  </div>

  <div class="card">
    <div class="small muted">Deep Liquidity Radar (Far Walls)</div>
    <div class="radar" style="margin-top:10px">
      <div class="row">
        <div style="flex:1">
          <h4>5 Large Buys (below price, nearest first)</h4>
          <div id="farBuys" class="col table">—</div>
        </div>
        <div style="width:18px"></div>
        <div style="flex:1">
          <h4>5 Large Sells (above price, nearest first)</h4>
          <div id="farSells" class="col table">—</div>
        </div>
      </div>

      <div style="display:flex;gap:10px;margin-top:10px;align-items:center">
        <label class="small muted">Distance filter (%)</label>
        <input id="radarDistPct" value="2" style="width:70px" />
        <label class="small muted">Min wall qty (native)</label>
        <input id="radarMinQty" value="50" style="width:80px" />
        <div class="small muted">Mode: deep REST snapshot (depth1000) + WS top20</div>
      </div>
    </div>
  </div>

  <div class="card">
    <div class="small muted">L2 Walls (depth20)</div>
    <div class="l2-grid" style="margin-top:8px">
      <div>
        <div class="small muted">BIDS (price — qty)</div>
        <div id="buyWalls" class="table" style="max-height:260px;overflow:auto;margin-top:6px"></div>
      </div>
      <div>
        <div class="small muted">ASKS (price — qty)</div>
        <div id="sellWalls" class="table" style="max-height:260px;overflow:auto;margin-top:6px"></div>
      </div>
    </div>
  </div>

</div>

<!-- ============================
     JS: Core Engine + Deep Radar + Historical Replay
     (Parts 2 + 3 combined; historical replay integrated)
     ============================ -->
<script>
/* ============================
   CONFIG
   ============================ */
const CALIBRATION_SECONDS = 180;
const WALL_SIZE_DEFAULT = 50;
const BURST_WINDOW_MS = 2500;
const MAX_TRADES_DISPLAY = 200;
const AGG_MAX = 200;

/* ============================
   STATE
   ============================ */
let ws = null;
let running = false;
let symbol = null;
let useMode = 'both'; // 'ws' | 'rest' | 'both'

let buyVol = 0, sellVol = 0, cumDelta = 0;
let recentTrades = []; // {price, qty, side, ts}
let bids = [], asks = [];
let lastPrice = null, lastPrice2 = null;
let lastHigh = null, lastLow = null;
let lastDeltaSide = null;
let lastOrderbookSnapshot = null;

let agg1m = []; // {tStart, buyVol, sellVol, delta, price}
let agg5m = []; // same structure

/* deep walls */
let deepBids = [];
let deepAsks = [];
let deepFetchTimer = null;
let farRadarTimer = null;
let deepFetchIntervalMs = 15000;
let farRadarRefreshMs = 1000;
let lastDeepFetchAt = 0;

/* ============================
   UI REFS
   ============================ */
const symbolSelect = document.getElementById('symbol');
const modeSelect = document.getElementById('modeSelect');
const connectBtn = document.getElementById('connectBtn');
const disconnectBtn = document.getElementById('disconnectBtn');
const statusEl = document.getElementById('status');

const tradesEl = document.getElementById('trades');
const logsEl = document.getElementById('logs');
const buyWallsEl = document.getElementById('buyWalls');
const sellWallsEl = document.getElementById('sellWalls');
const topBidsEl = document.getElementById('topBids');
const topAsksEl = document.getElementById('topAsks');

const buyClusterEl = document.getElementById('buyCluster');
const sellClusterEl = document.getElementById('sellCluster');

const volsEl = document.getElementById('vols');
const cumlEl = document.getElementById('cumlDelta');
const strengthEl = document.getElementById('strength');
const sweepInfoEl = document.getElementById('sweepInfo');
const divergenceInfoEl = document.getElementById('divergenceInfo');
const swingPanelContainer = document.getElementById('swingPanelContainer');
const buyBurstEl = document.getElementById('buyBurst');
const sellBurstEl = document.getElementById('sellBurst');
const aggrEl = document.getElementById('aggr');

const wallSizeInput = document.getElementById('wallSize');
const burstCntInput = document.getElementById('burstCnt');

const clearBtn = document.getElementById('clearBtn');
const downloadBtn = document.getElementById('downloadBtn');

const calibEl = document.getElementById('calib');

const farBuysEl = document.getElementById('farBuys');
const farSellsEl = document.getElementById('farSells');
const radarDistPctInput = document.getElementById('radarDistPct');
const radarMinQtyInput = document.getElementById('radarMinQty');

/* ============================
   HELPERS
   ============================ */
const f = v => (v === undefined || v === null) ? 0 : parseFloat(v);
const now = () => Date.now();
function log(msg){
  const d = document.createElement('div');
  d.innerText = `[${(new Date()).toLocaleTimeString()}] ${msg}`;
  logsEl.prepend(d);
  if(logsEl.childElementCount > 300) logsEl.removeChild(logsEl.lastChild);
}

/* ============================
   SYMBOL LOADER
   ============================ */
async function loadSymbols(){
  const url = "https://fapi.binance.com/fapi/v1/exchangeInfo";
  try{
    const res = await fetch(url);
    const data = await res.json();
    const list = data.symbols
      .filter(s => s.contractType === "PERPETUAL" && s.status === "TRADING")
      .map(s => s.symbol)
      .sort();
    if(list.length === 0) throw new Error("No symbols");
    symbolSelect.innerHTML = list.map(s => `<option>${s}</option>`).join('');
    const defIdx = list.indexOf('BTCUSDT');
    if(defIdx>=0) symbolSelect.selectedIndex = defIdx;
    symbol = symbolSelect.value;
    log(`Loaded ${list.length} symbols`);
  }catch(e){
    console.warn("Symbol load failed", e);
    symbolSelect.innerHTML = `<option>BTCUSDT</option><option>ETHUSDT</option><option>SOLUSDT</option>`;
    symbol = symbolSelect.value;
    log('Symbol list fallback applied');
  }
}
loadSymbols();

/* ============================
   UI SCHEDULER & UPDATE
   ============================ */
let uiTimer = null;
function scheduleUI(){ if(uiTimer) return; uiTimer = setTimeout(()=>{ uiTimer = null; updateUI(); }, 120); }

function updateUI(){
  volsEl.innerText = `${buyVol.toFixed(6)} / ${sellVol.toFixed(6)}`;
  cumlEl.innerText = cumDelta.toFixed(6);
  const bidsByPrice = bids.map(x=>[f(x[0]), f(x[1])]).sort((a,b)=>b[0]-a[0]);
  const asksByPrice = asks.map(x=>[f(x[0]), f(x[1])]).sort((a,b)=>a[0]-b[0]);
  document.getElementById('bestBid').innerText = bidsByPrice.length ? bidsByPrice[0][0] : '-';
  document.getElementById('bestAsk').innerText = asksByPrice.length ? asksByPrice[0][0] : '-';
  const topB = bidsByPrice.slice().sort((a,b)=>b[1]-a[1]).slice(0,12);
  const topA = asksByPrice.slice().sort((a,b)=>b[1]-a[1]).slice(0,12);
  topBidsEl.innerHTML = topB.map(it=>`${it[0]} — ${it[1]}`).join('<br>');
  topAsksEl.innerHTML = topA.map(it=>`${it[0]} — ${it[1]}`).join('<br>');
  buyWallsEl.innerHTML = bidsByPrice.map(it=>`${it[0]} — ${it[1]}`).join('<br>');
  sellWallsEl.innerHTML = asksByPrice.map(it=>`${it[0]} — ${it[1]}`).join('<br>');
  const wallSize = parseFloat(wallSizeInput.value) || WALL_SIZE_DEFAULT;
  const buyClusterCount = topB.filter(it=>it[1] > wallSize).length;
  const sellClusterCount = topA.filter(it=>it[1] > wallSize).length;
  buyClusterEl.innerText = String(buyClusterCount);
  sellClusterEl.innerText = String(sellClusterCount);
  const windowStart = now() - BURST_WINDOW_MS;
  const recentWindow = recentTrades.filter(r => r.ts >= windowStart);
  const buyAgg = recentWindow.filter(r => r.side === 'buy').length;
  const sellAgg = recentWindow.filter(r => r.side === 'sell').length;
  buyBurstEl.innerText = String(buyAgg);
  sellBurstEl.innerText = String(sellAgg);
  aggrEl.innerText = buyAgg>sellAgg ? 'BUY' : (sellAgg>buyAgg ? 'SELL' : '—');
  const ratio = buyVol / Math.max(sellVol, 1e-9);
  if(ratio > 1.6) strengthEl.innerText = 'BUYERS DOMINANT';
  else if(ratio > 1.2) strengthEl.innerText = 'Buyers Strong';
  else if(ratio < 0.4) strengthEl.innerText = 'SELLERS DOMINANT';
  else if(ratio < 0.6) strengthEl.innerText = 'Sellers Strong';
  else strengthEl.innerText = 'Balanced';
}

/* ============================
   CLEAR STATE
   ============================ */
function clearAll(){
  buyVol = 0; sellVol = 0; cumDelta = 0;
  recentTrades = [];
  bids = []; asks = [];
  lastPrice = lastPrice2 = null;
  lastHigh = lastLow = null;
  lastDeltaSide = null;
  agg1m = []; agg5m = [];
  swingPanelContainer.innerHTML = '';
  logsEl.innerHTML = '';
  updateUI();
  log('State cleared');
}

/* ============================
   AGGREGATION
   ============================ */
function aggregateConfluence(price, qty, side, ts){
  const minute = Math.floor(ts / 60000) * 60000;
  const fiveMinute = Math.floor(ts / (5*60000)) * (5*60000);
  let b1 = (agg1m.length && agg1m[agg1m.length-1].tStart === minute) ? agg1m[agg1m.length-1] : null;
  if(!b1){
    b1 = { tStart: minute, buyVol:0, sellVol:0, delta:0, price: price };
    agg1m.push(b1);
    if(agg1m.length > AGG_MAX) agg1m.shift();
  }
  b1.price = price;
  if(side === 'buy'){ b1.buyVol += qty; b1.delta += qty; } else { b1.sellVol += qty; b1.delta -= qty; }
  let b5 = (agg5m.length && agg5m[agg5m.length-1].tStart === fiveMinute) ? agg5m[agg5m.length-1] : null;
  if(!b5){
    b5 = { tStart: fiveMinute, buyVol:0, sellVol:0, delta:0, price: price };
    agg5m.push(b5);
    if(agg5m.length > AGG_MAX) agg5m.shift();
  }
  b5.price = price;
  if(side === 'buy'){ b5.buyVol += qty; b5.delta += qty; } else { b5.sellVol += qty; b5.delta -= qty; }
}

/* ============================
   DIVERGENCE DETECTION
   ============================ */
function detectDeltaDivergence(){
  if(agg1m.length < 4) return '—';
  const last4 = agg1m.slice(-4);
  const p0 = last4[0].price;
  const p3 = last4[3].price;
  const d0 = last4[0].delta;
  const d3 = last4[3].delta;
  if(typeof p0 !== 'number' || typeof p3 !== 'number' || typeof d0 !== 'number' || typeof d3 !== 'number') return '—';
  const priceUp = p3 > p0 + 0;
  const deltaDown = d3 < d0 - 0;
  const priceDown = p3 < p0 - 0;
  const deltaUp = d3 > d0 + 0;
  if(priceUp && deltaDown) return 'BEAR divergence';
  if(priceDown && deltaUp) return 'BULL divergence';
  return 'No divergence';
}

/* ============================
   SWING ENGINE
   ============================ */
function rateSwing(st){
  const flags = [st.sweep, st.deltaFlip, st.momentum, st.wallShift, st.reaction];
  const n = flags.filter(x=>x==='YES').length;
  const filled = '★'.repeat(n);
  const empty = '☆'.repeat(5 - n);
  return `<span class="stars">${filled}${empty}</span>`;
}

function showSwingPanel(type, price, st){
  const color = type === 'HIGH' ? '#ff4444' : '#00ff88';
  const title = type === 'HIGH' ? 'SWING HIGH' : 'SWING LOW';
  const stars = rateSwing(st);
  const html = `
    <div class="alertBox ${type==='HIGH' ? 'swing-high' : 'swing-low'}">
      <strong style="color:${color};font-size:15px">${title} @ ${price}</strong><br><br>
      • Liquidity Sweep: <b>${st.sweep}</b><br>
      • Delta Flip: <b>${st.deltaFlip}</b><br>
      • Momentum: <b>${st.momentum}</b><br>
      • Wall Shift: <b>${st.wallShift}</b><br>
      • Reaction Speed: <b>${st.reaction}</b><br>
      <hr>
      <b>Swing Rating: ${stars}</b>
    </div>
  `;
  swingPanelContainer.innerHTML = html + swingPanelContainer.innerHTML;
  log(`${title} @ ${price} | ${stars.replace(/<.*?>/g,'')}`);
}

function wallShiftDetected(){
  if(!lastOrderbookSnapshot) return false;
  try{
    const oldTopBuy = lastOrderbookSnapshot.bids[0]?.[1] ?? 0;
    const oldTopSell = lastOrderbookSnapshot.asks[0]?.[1] ?? 0;
    const newTopBuy = bids[0]?.[1] ?? 0;
    const newTopSell = asks[0]?.[1] ?? 0;
    return (newTopBuy > oldTopBuy * 1.4) || (newTopSell > oldTopSell * 1.4);
  }catch(e){ return false; }
}

function detectSwing(price){
  const deltaSide = cumDelta > 0 ? 'buy' : 'sell';
  const deltaFlipToBuy = lastDeltaSide === 'sell' && deltaSide === 'buy';
  const deltaFlipToSell = lastDeltaSide === 'buy' && deltaSide === 'sell';
  const sweepHigh = (lastHigh !== null && price > lastHigh);
  const sweepLow  = (lastLow !== null && price < lastLow);
  const momentum = Math.abs(cumDelta) > 25;
  const wallShift = wallShiftDetected();
  const reaction = (lastPrice2 !== null) ? (Math.abs(price - lastPrice2) > Math.abs(lastPrice - lastPrice2) * 1.5) : false;
  const swingStatus = {
    sweep: (sweepHigh || sweepLow) ? 'YES' : 'NO',
    deltaFlip: (deltaFlipToBuy || deltaFlipToSell) ? 'YES' : 'NO',
    momentum: momentum ? 'YES' : 'NO',
    wallShift: wallShift ? 'YES' : 'NO',
    reaction: reaction ? 'YES' : 'NO'
  };
  if(sweepHigh && deltaFlipToSell){
    showSwingPanel('HIGH', price, swingStatus);
  }
  if(sweepLow && deltaFlipToBuy){
    showSwingPanel('LOW', price, swingStatus);
  }
  lastDeltaSide = deltaSide;
  if(lastHigh === null || price > lastHigh) lastHigh = price;
  if(lastLow === null || price < lastLow) lastLow = price;
}

/* ============================
   HANDLERS: depth & trade
   ============================ */
function handleDepthPayload(payload){
  if(payload.b) bids = payload.b.slice();
  if(payload.a) asks = payload.a.slice();
  lastOrderbookSnapshot = { bids: bids.slice(), asks: asks.slice() };
  scheduleUI();
}

function handleTradePayload(t){
  const price = f(t.p);
  const qty = f(t.q);
  const isMaker = !!t.m;
  const side = isMaker ? 'sell' : 'buy';
  const ts = now();
  recentTrades.unshift({ price, qty, side, ts });
  if(recentTrades.length > 2000) recentTrades.pop();
  if(side === 'buy'){ buyVol += qty; cumDelta += qty; }
  else { sellVol += qty; cumDelta -= qty; }
  lastPrice2 = lastPrice;
  lastPrice = price;
  aggregateConfluence(price, qty, side, ts);
  const el = document.createElement('div');
  el.className = 'trade ' + (side === 'buy' ? 'buy' : 'sell');
  el.innerHTML = `<div style="opacity:0.9">${side.toUpperCase()} <span style="opacity:0.6">${price}</span></div><div>${qty.toFixed(6)}</div>`;
  tradesEl.prepend(el);
  while(tradesEl.childElementCount > MAX_TRADES_DISPLAY) tradesEl.removeChild(tradesEl.lastChild);
  detectSwing(price);
  try{ divergenceInfoEl.innerText = detectDeltaDivergence(); }catch(e){ divergenceInfoEl.innerText = '—'; }
  const sweepText = (lastHigh === null && lastLow === null) ? '—' : `Sweep: High=${(lastPrice>lastHigh? 'YES':'NO')} | Low=${(lastPrice<lastLow? 'YES':'NO')}`;
  sweepInfoEl.innerText = sweepText;
  scheduleUI();
}

/* ============================
   CONNECT / WS
   ============================ */
connectBtn.addEventListener('click', () => {
  if(running) return;
  symbol = symbolSelect.value.trim();
  useMode = modeSelect.value || 'both';
  if(!symbol){ alert('Select a symbol'); return; }

  clearAll(); // clear before replay
  const stream = `${symbol.toLowerCase()}@trade/${symbol.toLowerCase()}@depth20@100ms`;
  const url = `wss://fstream.binance.com/stream?streams=${stream}`;

  ws = new WebSocket(url);
  statusEl.innerText = 'Connecting...';

  ws.onopen = () => {
    statusEl.innerText = 'Connected';
    running = true;
    connectBtn.style.display = 'none';
    disconnectBtn.style.display = 'inline-block';
    log('WS open');

    // Historical replay: load last 10 minutes of aggTrades, then engine will be initialized
    loadHistoricalTrades(symbol).then(() => {
      log("Historical baseline built. Now live data will be accurate instantly.");
    });

    startCalibration();

    // start deep polling if needed (Part3)
    if(useMode === 'rest' || useMode === 'both'){
      startDeepPolling();
    }
  };

  ws.onmessage = ev => {
    try{
      const msg = JSON.parse(ev.data);
      const payload = msg.data || msg;
      if(!payload) return;
      if(payload.e === 'trade' || payload.e === 'aggTrade' || payload.p){
        const trade = payload.e ? payload : payload.data || payload;
        handleTradePayload(trade);
      }
      if(payload.b || payload.a){
        const depth = payload;
        handleDepthPayload(depth);
      }
    }catch(e){
      console.warn('ws parse', e);
    }
  };

  ws.onerror = e => {
    statusEl.innerText = 'WS error';
    log('WS error');
    console.error(e);
  };

  ws.onclose = () => {
    statusEl.innerText = 'Disconnected';
    running = false;
    connectBtn.style.display = 'inline-block';
    disconnectBtn.style.display = 'none';
    stopCalibration();
    stopDeepPolling();
    log('WS closed');
  };
});

disconnectBtn.addEventListener('click', () => {
  if(ws) ws.close();
  ws = null;
  running = false;
  statusEl.innerText = 'Disconnected';
  connectBtn.style.display = 'inline-block';
  disconnectBtn.style.display = 'none';
  stopCalibration();
  stopDeepPolling();
});

/* ============================
   DOWNLOAD CSV, CLEAR, CALIBRATION
   ============================ */
downloadBtn.addEventListener('click', () => {
  const rows = ['side,price,qty'];
  bids.forEach(b => rows.push(`bid,${b[0]},${b[1]}`));
  asks.forEach(a => rows.push(`ask,${a[0]},${a[1]}`));
  const blob = new Blob([rows.join('\n')], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = `${symbol || 'snapshot'}_l2.csv`; a.click();
  URL.revokeObjectURL(url);
});

clearBtn.addEventListener('click', clearAll);

let calibrationStartedAt = null;
let calibrationInterval = null;
function startCalibration(){
  calibrationStartedAt = now();
  calibEl.innerText = `Calibrating…`;
  if(calibrationInterval) clearInterval(calibrationInterval);
  calibrationInterval = setInterval(()=>{
    if(!calibrationStartedAt){ clearInterval(calibrationInterval); return; }
    const elapsed = Math.floor((now() - calibrationStartedAt) / 1000);
    const remaining = CALIBRATION_SECONDS - elapsed;
    if(remaining <= 0){
      calibEl.innerText = 'READY ✓';
      clearInterval(calibrationInterval);
      log('Calibration complete — engine ready');
    } else {
      calibEl.innerText = `Calibrating… ${remaining}s`;
    }
  }, 800);
}
function stopCalibration(){
  calibrationStartedAt = null;
  calibEl.innerText = 'Not running';
  if(calibrationInterval) clearInterval(calibrationInterval);
}

/* ============================
   HISTORICAL REPLAY (last 10 minutes) - Option A
   ============================ */
async function loadHistoricalTrades(sym){
  try {
    const endTime = Date.now();
    const startTime = endTime - (10 * 60 * 1000); // last 10 minutes
    log(`Fetching 10 min historical trades for ${sym}...`);
    // Binance aggTrades supports startTime,endTime but may return up to 1000 items per request.
    // We'll fetch in a loop if needed, but usually 10 minutes fits in 1000 aggTrades for many symbols.
    const url = `https://fapi.binance.com/fapi/v1/aggTrades?symbol=${encodeURIComponent(sym)}&startTime=${startTime}&endTime=${endTime}&limit=1000`;
    const res = await fetch(url);
    const data = await res.json();
    if(!Array.isArray(data)){
      log("Historical load failed (not array)");
      return;
    }
    log(`Loaded ${data.length} historical trades — Replaying...`);
    // Replay each trade (small delay avoided for speed)
    for(const t of data){
      const trade = { p: t.p, q: t.q, m: t.m };
      handleTradePayload(trade);
    }
    log("Historical replay complete — Engine is fully initialized!");
  } catch (e) {
    console.error(e);
    log("Historical replay failed");
  }
}

/* ============================
   DEEP SNAPSHOT (REST) + FAR RADAR
   ============================ */
function safeParseNumber(v){ const n = parseFloat(v); return Number.isFinite(n) ? n : 0; }
function formatPrice(p){ return (typeof p === 'number') ? p.toFixed(4) : String(p); }

async function fetchDeepSnapshot(sym){
  if(!sym) return;
  const url = `https://fapi.binance.com/fapi/v1/depth?symbol=${encodeURIComponent(sym)}&limit=1000`;
  try{
    lastDeepFetchAt = Date.now();
    const res = await fetch(url);
    if(!res.ok) throw new Error('HTTP ' + res.status);
    const data = await res.json();
    deepBids = (data.b || []).map(x => [safeParseNumber(x[0]), safeParseNumber(x[1])]);
    deepAsks = (data.a || []).map(x => [safeParseNumber(x[0]), safeParseNumber(x[1])]);
    deepBids.sort((a,b)=>b[0]-a[0]);
    deepAsks.sort((a,b)=>a[0]-b[0]);
    log(`Deep snapshot fetched: bids=${deepBids.length} asks=${deepAsks.length}`);
  }catch(err){
    console.warn('deep snapshot failed', err);
    log('Deep snapshot fetch failed');
  }
}

function computeFarWalls(){
  let currentPrice = lastPrice;
  if(!currentPrice){
    const bestBid = bids[0] ? safeParseNumber(bids[0][0]) : null;
    const bestAsk = asks[0] ? safeParseNumber(asks[0][0]) : null;
    if(bestBid && bestAsk) currentPrice = (bestBid + bestAsk) / 2;
    else currentPrice = null;
  }
  if(!currentPrice || (!deepBids.length && !deepAsks.length)){
    farBuysEl.innerHTML = '—';
    farSellsEl.innerHTML = '—';
    return;
  }
  const distPct = Math.max(0, safeParseNumber(radarDistPctInput.value));
  const minQty = Math.max(0, safeParseNumber(radarMinQtyInput.value));
  const buyThresholdPrice = currentPrice * (1 - distPct/100);
  const sellsThresholdPrice = currentPrice * (1 + distPct/100);
  const candidateBuys = deepBids
    .filter(([p,q]) => p <= buyThresholdPrice && q >= minQty)
    .sort((a,b)=>b[0]-a[0])
    .slice(0, 50);
  const buysSelected = candidateBuys.slice(0,5);
  const candidateSells = deepAsks
    .filter(([p,q]) => p >= sellsThresholdPrice && q >= minQty)
    .sort((a,b)=>a[0]-b[0])
    .slice(0,50);
  const sellsSelected = candidateSells.slice(0,5);
  if(buysSelected.length === 0) farBuysEl.innerHTML = '—';
  else {
    const rows = buysSelected.map(([p,q])=>{
      const pctDist = ((currentPrice - p) / currentPrice) * 100;
      return `<div><b>${formatPrice(p)}</b> — ${q.toFixed(4)}  <span style="opacity:0.65">(${pctDist.toFixed(2)}% below)</span></div>`;
    });
    farBuysEl.innerHTML = rows.join('');
  }
  if(sellsSelected.length === 0) farSellsEl.innerHTML = '—';
  else {
    const rows = sellsSelected.map(([p,q])=>{
      const pctDist = ((p - currentPrice) / currentPrice) * 100;
      return `<div><b>${formatPrice(p)}</b> — ${q.toFixed(4)}  <span style="opacity:0.65">(${pctDist.toFixed(2)}% above)</span></div>`;
    });
    farSellsEl.innerHTML = rows.join('');
  }
}

function startDeepPolling(){
  if(deepFetchTimer) clearInterval(deepFetchTimer);
  if(farRadarTimer) clearInterval(farRadarTimer);
  fetchDeepSnapshot(symbol).catch(()=>{});
  deepFetchTimer = setInterval(()=>{ if(symbol) fetchDeepSnapshot(symbol); }, deepFetchIntervalMs);
  computeFarWalls();
  farRadarTimer = setInterval(()=>{ computeFarWalls(); }, farRadarRefreshMs);
}

function stopDeepPolling(){
  if(deepFetchTimer) clearInterval(deepFetchTimer);
  if(farRadarTimer) clearInterval(farRadarTimer);
  deepFetchTimer = null;
  farRadarTimer = null;
}

symbolSelect.addEventListener('change', (e)=>{
  symbol = e.target.value;
  if(running && (useMode === 'rest' || useMode === 'both')){
    fetchDeepSnapshot(symbol);
  }
});

connectBtn.addEventListener('click', ()=>{
  if(useMode === 'rest' || useMode === 'both'){
    startDeepPolling();
  }
});

disconnectBtn.addEventListener('click', ()=>{
  stopDeepPolling();
});

document.addEventListener('visibilitychange', ()=>{
  if(document.hidden){
    if(deepFetchTimer) clearInterval(deepFetchTimer);
  } else {
    if(useMode === 'rest' || useMode === 'both'){
      if(!deepFetchTimer) deepFetchTimer = setInterval(()=>{ if(symbol) fetchDeepSnapshot(symbol); }, deepFetchIntervalMs);
    }
  }
});

setTimeout(()=>{ if(symbolSelect.value) { symbol = symbolSelect.value; fetchDeepSnapshot(symbol); } }, 1200);

setInterval(()=>{ try{ computeFarWalls(); }catch(e){} }, 2000);

/* ============================
   HISTORICAL "HUGE WALLS" SEED (optional)
   We will also seed deep walls rendering once deep snapshot arrives.
   ============================ */

/* ============================
   INITIALIZE UI & READY
   ============================ */
clearAll();
updateUI();
log('Dashboard ready. Click Connect.');

// light UI updater
setInterval(()=>{ scheduleUI(); }, 1000);

</script>
</body>
</html>
